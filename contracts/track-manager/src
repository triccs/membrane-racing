
// track_manager/src/contract.rs

use cosmwasm_std::{Deps, DepsMut, Env, MessageInfo, Response, StdResult, Binary, to_binary};
use cw2::set_contract_version;
use crate::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
use crate::state::{Track, TrackTile, TileType, TRACKS};
use std::collections::VecDeque;

const CONTRACT_NAME: &str = "crates.io:track-manager";
const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");

pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: InstantiateMsg,
) -> StdResult<Response> {
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
    Ok(Response::default())
}

pub fn execute(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: ExecuteMsg,
) -> StdResult<Response> {
    match msg {
        ExecuteMsg::AddTrack { track_id, name, grid } => execute_add_track(deps, track_id, name, grid),
    }
}

pub fn query(
    deps: Deps,
    _env: Env,
    msg: QueryMsg,
) -> StdResult<Binary> {
    match msg {
        QueryMsg::GetTrack { track_id } => to_binary(&TRACKS.load(deps.storage, track_id)?),
    }
}

fn execute_add_track(
    deps: DepsMut,
    track_id: u64,
    name: String,
    grid: Vec<Vec<TileType>>,
) -> StdResult<Response> {
    let height = grid.len() as u8;
    let width = if height > 0 { grid[0].len() as u8 } else { 0 };

    let mut layout: Vec<Vec<TrackTile>> = vec![vec![TrackTile { tile_type: TileType::Wall, distance_from_finish: u16::MAX }; width as usize]; height as usize];
    let mut queue: VecDeque<(usize, usize, u16)> = VecDeque::new();

    for y in 0..height as usize {
        for x in 0..width as usize {
            let tile = grid[y][x];
            layout[y][x].tile_type = tile;
            if tile == TileType::Finish {
                layout[y][x].distance_from_finish = 0;
                queue.push_back((x, y, 0));
            }
        }
    }

    let directions = [(0i32, 1i32), (1, 0), (0, -1), (-1, 0)];
    while let Some((x, y, dist)) = queue.pop_front() {
        for (dx, dy) in directions.iter() {
            let nx = x as i32 + dx;
            let ny = y as i32 + dy;
            if nx >= 0 && ny >= 0 && (ny as usize) < height as usize && (nx as usize) < width as usize {
                let nxu = nx as usize;
                let nyu = ny as usize;
                if layout[nyu][nxu].tile_type != TileType::Wall && layout[nyu][nxu].distance_from_finish > dist + 1 {
                    layout[nyu][nxu].distance_from_finish = dist + 1;
                    queue.push_back((nxu, nyu, dist + 1));
                }
            }
        }
    }

    let track = Track {
        id: track_id,
        name,
        width,
        height,
        layout,
    };
    TRACKS.save(deps.storage, track_id, &track)?;
    Ok(Response::new().add_attribute("action", "add_track").add_attribute("track_id", track_id.to_string()))
}

// track_manager/src/state.rs

use serde::{Deserialize, Serialize};
use schemars::JsonSchema;
use cw_storage_plus::Map;

pub static TRACKS: Map<u64, Track> = Map::new("tracks");

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]
pub struct Track {
    pub id: u64,
    pub name: String,
    pub width: u8,
    pub height: u8,
    pub layout: Vec<Vec<TrackTile>>, // 2D grid
}

#[derive(Serialize, Deserialize, Clone, Copy, Debug, PartialEq, Eq, JsonSchema)]
pub enum TileType {
    Normal,
    Boost,
    Stick,
    Slow,
    Wall,
    Finish,
}

#[derive(Serialize, Deserialize, Clone, Copy, Debug, PartialEq, Eq, JsonSchema)]
pub struct TrackTile {
    pub tile_type: TileType,
    pub distance_from_finish: u16,
}

// track_manager/src/msg.rs

use crate::state::TileType;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct InstantiateMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum ExecuteMsg {
    AddTrack {
        track_id: u64,
        name: String,
        grid: Vec<Vec<TileType>>,
    },
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum QueryMsg {
    GetTrack { track_id: u64 },
}
